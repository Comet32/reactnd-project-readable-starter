## 关于 React 应用与 React/Redux 应用的思考

在之前学习 React 开发的过程中，知道了 React 有展示型组件和容器型组件，展示型组件只需要负责 UI 方面的任务即可，比如视图的显示和绑定用户行为，而容器型组件则管理视图显示中的数据和用户行为所触发的回调。那么在开发的过程中，我们通过设计稿还有与 PM 之间的交谈来分析应用中组件该如何划分，哪些组件组件只需要负责显示，哪些组件则需要管理数据和行为所触发的回调。

到了学习使用 React/Redux 来进行开发的时候，数据和行为不再由容器型组件来管理，而是交给了 Redux，特别是使用了 connect 对组件进行包裹之后可以通过`mapStateToProps`和`mapDispatchToProps`时，一个组件可以从其`props`中获取到数据 state，也可以获取改变数据的行为，特别是使用`mapDispatchToProps`时，我们可以把整个行为都放到其返回的行为之中，其中可能包括了派发 action 的行为、改变 UI 的行为或者一些当用户行为发生时所触发的回调中所能够操作的所有逻辑。这样以后，似乎容器型组件消失了，因为所有状态都存放在了 store 中，我们也可以很方便的通过 connect 来「连接」任何组件以获取想要获取的任何数据。

但这样是存在问题的，一旦我们这样做了，展示型组件内部存在了除父组件获取数据以外的其他获取方式，其复用性会下降，除非你的应用不需要考虑复用性的问题。

所以，对于使用 React/Redux 的应用来说，实际上依然应该存在容器型组件。虽然对于使用`mapStateToProps`和`mapDispatchToProps`的容器型组件来说，似乎状态和行为并没有定义到其组件内部，但通过 connect 所「连接」返回的组件，其实质就是容器型组件本身，只是使用 HOC 得到来「升级」而已。

在「readable」应用中，我们似乎没有创建过展示型组件，那是因为使用了「antd」组件库缘故，我们从「antd」从所引入的组件就可以看作是展示型组件，而将其引入并传递数据和回调给这些展示型组件的组件，就是容器型组件。所以，我们依然还是采用了这种组件分离的形式进行了开发。而且，也可以将「antd」中的组件进行组合来形成自己的功能组件（带有功能性的展示型组件，比如应用中的排序按钮组）



## 异步、封装、抽象

> 在这里，我将「抽象」理解为将相同的行为「更上一级」的函数中进行执行的操作。
>
> 我理解的「封装」是指将一部分代码通过函数包裹起来，其内部执行的操作与外界解耦，而其与外部的联系来源于其接口（函数参数），根据传入的数据的不同来返回不同的数据。

为什么这里要谈这三点，但其实我并不能讲好这个问题，只是因为一个功能想要去试着思考这个问题。

功能是点击「Delete」按钮时会弹出 modal 用于提示是否确定删除，modal 是使用的`antd`的`Modal`组件，但这个组件的使用方式和以往所使用的是不同的，因为是直接通过调用一个函数来使用，和`message`很像。代码如下：

```jsx
import { Modal } from 'antd'

const confirm = Modal.confirm

export default function deleteConfirm(id, handleOk, pID) {
  confirm({
    title: '确定删除？',
    okText: '确定',
    cancelText: '取消',
    onOk() {
      handleOk(id, pID)
    }
  })
}
```

- 这里我将其封装为了一个组件，但其导出的是一个函数，虽然很奇怪，但从实际效果来说，其依然是一个组件，并且也暴露了一些接口用于使在不同的组件中的行为有所不同。
- 调用`deleteConfirm`之后就会出现 modal 提示


[TOC]

## 组件（页面）初始化状态

一个组件或者一个页面有一个初始状态，最好是利用组件本身 componentDidMount 钩子来设置这个状态，而不是通过其他组件来设置。当然，我指的是无论什么情况下回到这个页面，这个页面都需要呈现相同的状态。如果你因为在其他页面通过操作而改变了这个页面状态，那你还是需要在其他组件中通过对状态的改变来改变页面。

为什么会思考这个问题？

我的主页面中排序功能是默认以当前得分排序，当我点击其他排序方式过后，store 中的状态随之改变，我从其他页面回到这个页面时，由于我的 UI 依然是得分排序，但实际上的排序是其他排序方式，因为我 store 中的状态没有改变。

![1541303298123](assets/1541303298123.png)

最开始，我是通过当我点击确定提交或者确定修改后回来主页面时改变 store，但这样有一个问题，如果我只是通过向前向后的浏览器操作，并不会改变 store，因此我觉得一个页面的状态初始化，最好还是让组件（页面）本身来修改更好，如果其他组件或页面要改变这个状态，那么也可以改变。



## Link 组件中 onClick 传箭头函数的 this 问题

```jsx
<Link to={`/modify-post`} 
      onClick={(e) => {
      console.log(record.key)
      this.props.changeID(record.key)
      debugger
}}>Edit</Link>
```

这里的 this 指向的是 Link 这个组件，也就是这个类，而不是所在组件，具体原因目前还不清楚，但我的猜想是箭头函数会在 Link 这个组件内执行，而不是在父组件的位置执行，因此会指向 Link。

解决的办法是，不使用 this.props，而是将 this.porps 中的属性结构出来，再传入：

```jsx
const { changeID } = this.props
```



## dispatch 的异步性及一些关于程序的想法

```jsx
  componentDidMount(){
    const id = this.props.match.params.id
    this.props.dispatch(changePostID(id))
    console.log(this.props.post)
  }
```

这是 PostDetail 组件中的 componentDidMount。第三行代码中使用了 dispatch，但是在接下来的 console.log(this.props.post) 中，post 是空，也就是说 dispatch 过后并没有等待 dispatch 执行完毕，而是异步的，所以在接下来的代码中才无法接受到这个参数。可这并不是关键。

关键的问题是，我这里并不需要去 dispatch 来改变其 id，我只需要这个 id 就行了。我需要这个 id 来获取 post，并不需要先存储在 store 中，而为什么出现这个问题，是由于之前在主页面中点击 edit 跳转到编辑页面时，我需要一个 id，但这个 id 是在加载组件之前就要有，我就先存储到了 store 中。但这里是不需要这样操作的。。



## 使用 ref 引用时，如果节点不存在的处理方式

```jsx
  handleChangeEdit = (e) => {
    e.preventDefault()
    this.setState({
      isEdit: true
    })
    setTimeout(() => {
      this.textInput && this.textInput.focus()
    }, 50);
  }
  
  // 优化后
    handleChangeEdit = (e) => {
    e.preventDefault()
    this.setState({
      isEdit: true
    },()=>{this.textInput && this.textInput.focus()})
  }
```

上面这段代码是当我点击 Edit 按钮时所触发的，因为我想当点击的时候让光标聚焦在 textArea 框中，所以引用了 textArea。

问题在于还没有点击 Edit 时，页面中是不存在 textArea 的，所以引用时会出错。因此刚开始我延迟了执行的时间，让 textArea 在页面中出现时再引用并聚焦。但这存在一个问题，因为你不知道多久会执行完并出现，所以我先做了一个判断然后再执行聚焦。

优化后。第一种方式其实有点傻，原因是 this.setState 与 setTimeout 都是异步，目前我并不知道谁先执行，如果是 setTimeout 先执行，就会出现不聚焦的情况，因为页面中并没有 textArea。因此，我们可以在 setState 中的第二个参数中传入一个回调来执行。



## 注意，接口中修改的 method 是 PUT 而不是 POST

```jsx
// 修改某一评论的内容
export function changeCommentBodyAPI(id,body) {
  return fetch(`${api}/comments/${id}`, {
    headers: {
      ...headers,
      'Content-Type': 'application/json'
    },
    method: 'PUT',
    body: JSON.stringify({
      timestamp: Date.now(),
      body
    })
  }).then(res => res.json())
}
```

这里一直出现问题，服务器那边也返回了收到错误信息的提示，但一直没有找到问题。最后发现是由于 method 传入的是 POST 而不是 PUT



## antd 中 Input 组件 onClick 传入回调中的 this 指向问题

```jsx
  handleSubmitComment = (that) => {
    addCommentAPI({
      id: random24(),
      timestamp: Date.now(),
      body: that.bodyInput.textAreaRef.value,
      owner: that.authorInput.input.value,
      parentId: that.props.match.params.id
    }).then(res => {
      that.bodyInput.textAreaRef.value = ''
      that.authorInput.input.value = ''
      that.props.dispatch(getComments(that.props.match.params.id))
      that.props.dispatch(getPost(that.props.match.params.id))
    })
  }
  
  // 组件内部
 <Button onClick={()=>{this.handleSubmitComment(this)}} type="primary" size="large">
      发表评论
</Button> 
```

其实这个问题在之前使用 Link 时已经出现过了，在那个是时候我是讲 this 中的属性放到函数外面然后再传入这个属性，但其实也有另外一种非常好用的方式，就是使用 that 来代替 this，在传入回调时传入 this，这样在调用时就是当时环境下的 this，而不是执行环境的 this。